{"version":3,"sources":["../src/index.ts","../src/API.ts"],"sourcesContent":["import { API } from \"./API\";\nimport { CustomPlugin, DisTubeError, Playlist, Song, checkInvalidKey } from \"distube\";\nimport type { VoiceBasedChannel } from \"discord.js\";\nimport type { PlayOptions, PlaylistInfo, Queue, SearchResult } from \"distube\";\n\ntype Falsy = undefined | null | false | 0 | \"\";\nconst isTruthy = <T>(x: T | Falsy): x is T => Boolean(x);\n\nexport type SpotifyPluginOptions = {\n  api?: {\n    clientId?: string;\n    clientSecret?: string;\n    topTracksCountry?: string;\n  };\n  parallel?: boolean;\n  emitEventsAfterFetching?: boolean;\n};\n\nexport class SpotifyPlugin extends CustomPlugin {\n  api: API;\n  parallel: boolean;\n  emitEventsAfterFetching: boolean;\n  constructor(options: SpotifyPluginOptions = {}) {\n    super();\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new DisTubeError(\"INVALID_TYPE\", [\"object\", \"undefined\"], options, \"SpotifyPluginOptions\");\n    }\n    checkInvalidKey(options, [\"parallel\", \"emitEventsAfterFetching\", \"api\"], \"SpotifyPluginOptions\");\n    this.parallel = options.parallel ?? true;\n    if (typeof this.parallel !== \"boolean\") {\n      throw new DisTubeError(\"INVALID_TYPE\", \"boolean\", this.parallel, \"SpotifyPluginOptions.parallel\");\n    }\n    this.emitEventsAfterFetching = options.emitEventsAfterFetching ?? false;\n    if (typeof this.emitEventsAfterFetching !== \"boolean\") {\n      throw new DisTubeError(\n        \"INVALID_TYPE\",\n        \"boolean\",\n        this.emitEventsAfterFetching,\n        \"SpotifyPluginOptions.emitEventsAfterFetching\",\n      );\n    }\n    if (options.api !== undefined && (typeof options.api !== \"object\" || Array.isArray(options.api))) {\n      throw new DisTubeError(\"INVALID_TYPE\", [\"object\", \"undefined\"], options.api, \"api\");\n    } else if (options.api) {\n      if (options.api.clientId && typeof options.api.clientId !== \"string\") {\n        throw new DisTubeError(\"INVALID_TYPE\", \"string\", options.api.clientId, \"SpotifyPluginOptions.api.clientId\");\n      }\n      if (options.api.clientSecret && typeof options.api.clientSecret !== \"string\") {\n        throw new DisTubeError(\n          \"INVALID_TYPE\",\n          \"string\",\n          options.api.clientSecret,\n          \"SpotifyPluginOptions.api.clientSecret\",\n        );\n      }\n      if (options.api.topTracksCountry && typeof options.api.topTracksCountry !== \"string\") {\n        throw new DisTubeError(\n          \"INVALID_TYPE\",\n          \"string\",\n          options.api.topTracksCountry,\n          \"SpotifyPluginOptions.api.topTracksCountry\",\n        );\n      }\n    }\n    this.api = new API(options.api?.clientId, options.api?.clientSecret, options.api?.topTracksCountry);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  override async validate(url: string) {\n    if (typeof url !== \"string\" || !url.includes(\"spotify\")) return false;\n    try {\n      const parsedURL = this.api.parseUrl(url);\n      if (!parsedURL.type || !this.api.isSupportedTypes(parsedURL.type)) return false;\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  async play(voiceChannel: VoiceBasedChannel, url: string, options: PlayOptions) {\n    const DT = this.distube;\n    const data = await this.api.getData(url);\n    const { member, textChannel, skip, position, metadata } = Object.assign({ position: 0 }, options);\n    if (data.type === \"track\") {\n      const query = `${data.name} ${data.artists.map((a: any) => a.name).join(\" \")}`;\n      const result = await this.search(query);\n      if (!result) throw new DisTubeError(\"SPOTIFY_PLUGIN_NO_RESULT\", `Cannot find \"${query}\" on YouTube.`);\n      await DT.play(voiceChannel, result, options);\n    } else {\n      const { name, thumbnail, tracks } = data;\n      const queries = tracks.map(track => `${track.name} ${track.artists.map((a: any) => a.name).join(\" \")}`);\n      let firstSong: Song | undefined;\n      const getFirstSong = async () => {\n        const firstQuery = queries.shift();\n        if (!firstQuery) return;\n        const result = await this.search(firstQuery);\n        if (!result) return;\n        firstSong = new Song(result, { member, metadata });\n      };\n      while (!firstSong) await getFirstSong();\n\n      if (!firstSong) {\n        throw new DisTubeError(\"SPOTIFY_PLUGIN_NO_RESULT\", `Cannot find any tracks of \"${name}\" on YouTube.`);\n      }\n      const queue = DT.getQueue(voiceChannel);\n\n      const playlistInfo: PlaylistInfo = {\n        source: \"spotify\",\n        songs: [firstSong],\n        name,\n        thumbnail,\n        member,\n        url,\n      };\n      const playlist = new Playlist(playlistInfo, { member, metadata });\n      const fetchTheRest = async (q: Queue, fs: Song) => {\n        if (queries.length) {\n          let results: (SearchResult | null)[] = [];\n          if (this.parallel) {\n            results = await Promise.all(queries.map(query => this.search(query)));\n          } else {\n            for (let i = 0; i < queries.length; i++) {\n              results[i] = await this.search(queries[i]);\n            }\n          }\n          playlist.songs = results.filter(isTruthy).map(r => {\n            const s = new Song(r, { member, metadata });\n            s.playlist = playlist;\n            return s;\n          });\n          q.addToQueue(playlist.songs, !skip && position > 0 ? position + 1 : position);\n        }\n        playlist.songs.unshift(fs);\n      };\n      if (queue) {\n        queue.addToQueue(firstSong, position);\n        if (skip) queue.skip();\n        else if (!this.emitEventsAfterFetching) DT.emit(\"addList\", queue, playlist);\n        await fetchTheRest(queue, firstSong);\n        if (!skip && this.emitEventsAfterFetching) DT.emit(\"addList\", queue, playlist);\n      } else {\n        let newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);\n        while (newQueue === true) {\n          await getFirstSong();\n          newQueue = await DT.queues.create(voiceChannel, firstSong, textChannel);\n        }\n        if (!this.emitEventsAfterFetching) {\n          if (DT.options.emitAddListWhenCreatingQueue) DT.emit(\"addList\", newQueue, playlist);\n          DT.emit(\"playSong\", newQueue, firstSong);\n        }\n        await fetchTheRest(newQueue, firstSong);\n        if (this.emitEventsAfterFetching) {\n          if (DT.options.emitAddListWhenCreatingQueue) DT.emit(\"addList\", newQueue, playlist);\n          DT.emit(\"playSong\", newQueue, firstSong);\n        }\n      }\n    }\n  }\n\n  async search(query: string) {\n    try {\n      return (await this.distube.search(query, { limit: 1 }))[0];\n    } catch {\n      return null;\n    }\n  }\n}\n\nexport default SpotifyPlugin;\n","import SpotifyInfo from \"spotify-url-info\";\nimport SpotifyWebApi from \"spotify-web-api-node\";\nimport { fetch } from \"undici\";\nimport { parse as parseSpotifyUri } from \"spotify-uri\";\nimport { DisTubeError } from \"distube\";\n\nconst SUPPORTED_TYPES = [\"album\", \"playlist\", \"track\", \"artist\"] as const;\n\nconst api = new SpotifyWebApi();\nconst info = SpotifyInfo(fetch);\n\ntype Track = {\n  type: \"track\";\n  name: string;\n  artists: { name: string }[];\n};\n\ntype EmbedList = {\n  type: \"album\" | \"playlist\" | \"artist\";\n  title: string;\n  subtitle: string;\n  trackList: { title: string; subtitle: string }[];\n  coverArt?: {\n    sources?: { url: string }[];\n  };\n};\n\ntype DataList = {\n  type: string;\n  name: string;\n  thumbnail?: string;\n  url: string;\n  tracks: Track[];\n};\n\ntype Album = DataList & { type: \"album\" };\ntype Playlist = DataList & { type: \"playlist\" };\ntype Artist = DataList & { type: \"artist\" };\ntype TrackList = Album | Playlist | Artist;\ntype Data = Track | TrackList;\n\nlet firstWarning1 = true;\nlet firstWarning2 = true;\n\nconst apiError = (e: any) =>\n  new DisTubeError(\n    \"SPOTIFY_API_ERROR\",\n    `The URL is private or unavailable.${e?.body?.error?.message ? `\\nDetails: ${e.body.error.message}` : \"\"}${\n      e?.statusCode ? `\\nStatus code: ${e.statusCode}.` : \"\"\n    }`,\n  );\n\nexport class API {\n  private _hasCredentials = false;\n  private _expirationTime = 0;\n  private _tokenAvailable = false;\n  topTracksCountry = \"US\";\n\n  constructor(clientId?: string, clientSecret?: string, topTracksCountry?: string) {\n    if (clientId && clientSecret) {\n      this._hasCredentials = true;\n      api.setClientId(clientId);\n      api.setClientSecret(clientSecret);\n    }\n    if (topTracksCountry) {\n      if (!/^[A-Z]{2}$/.test(topTracksCountry)) throw new Error(\"Invalid region code\");\n      this.topTracksCountry = topTracksCountry;\n    }\n  }\n\n  isSupportedTypes(type: string): type is typeof SUPPORTED_TYPES[number] {\n    return SUPPORTED_TYPES.includes(<any>type);\n  }\n\n  async refreshToken() {\n    if (Date.now() < this._expirationTime) return;\n    if (this._hasCredentials) {\n      try {\n        const { body } = await api.clientCredentialsGrant();\n        api.setAccessToken(body.access_token);\n        this._expirationTime = Date.now() + body.expires_in * 1000 - 5_000;\n      } catch (e) {\n        if (firstWarning1) {\n          firstWarning1 = false;\n          this._hasCredentials = false;\n          /* eslint-disable no-console */\n          console.warn(e);\n          console.warn(\"[SPOTIFY_PLUGIN_API] Cannot get token from your credentials. Try scraping token instead.\");\n          /* eslint-enable no-console */\n        }\n      }\n    }\n    if (!this._hasCredentials) {\n      const response = await fetch(\"https://open.spotify.com/\");\n      const body = await response.text();\n      const token = body.match(/\"accessToken\":\"(.+?)\"/)?.[1];\n      if (!token) {\n        this._tokenAvailable = false;\n        if (firstWarning2) {\n          firstWarning2 = false;\n          /* eslint-disable no-console */\n          console.warn(\n            \"[SPOTIFY_PLUGIN_API] Cannot get token from scraping. \" +\n              \"Cannot fetch more than 100 tracks from a playlist or album.\",\n          );\n          /* eslint-enable no-console */\n        }\n        return;\n      }\n      api.setAccessToken(token);\n      const expiration = body.match(/\"accessTokenExpirationTimestampMs\":(\\d+)/)?.[1];\n      if (expiration) this._expirationTime = Number(expiration) - 5_000;\n      // Else: token should be valid right now, but don't know when it expires\n    }\n    this._tokenAvailable = true;\n  }\n\n  parseUrl(url: string) {\n    return parseSpotifyUri(url);\n  }\n\n  getData(url: `${string}/track/${string}`): Promise<Track>;\n  getData(url: `${string}/album/${string}`): Promise<Album>;\n  getData(url: `${string}/playlist/${string}`): Promise<Playlist>;\n  getData(url: `${string}/artist/${string}`): Promise<Artist>;\n  getData(url: string): Promise<Data>;\n  async getData(url: string): Promise<Data> {\n    const parsedUrl = this.parseUrl(url);\n    const id = (<any>parsedUrl).id;\n    if (!id) throw new DisTubeError(\"SPOTIFY_API_INVALID_URL\", \"Invalid URL\");\n    if (!this.isSupportedTypes(parsedUrl.type)) {\n      throw new DisTubeError(\"SPOTIFY_API_UNSUPPORTED_TYPE\", \"Unsupported URL type\");\n    }\n    await this.refreshToken();\n    if (parsedUrl.type === \"track\") {\n      if (!this._tokenAvailable) return info.getData(url);\n      return api\n        .getTrack(id)\n        .then(({ body }) => body)\n        .catch(e => {\n          throw apiError(e);\n        });\n    }\n    if (!this._tokenAvailable) {\n      const data = (await info.getData(url)) as EmbedList;\n      return {\n        type: parsedUrl.type,\n        name: data.title,\n        thumbnail: data.coverArt?.sources?.[0]?.url,\n        url,\n        tracks: data.trackList.map(i => ({\n          type: \"track\",\n          name: i.title,\n          artists: [{ name: i.subtitle }],\n        })),\n      };\n    }\n    let name: string, thumbnail: string, tracks: Track[];\n    try {\n      switch (parsedUrl.type) {\n        case \"album\": {\n          const { body } = await api.getAlbum(id);\n          name = body.name;\n          thumbnail = body.images?.[0]?.url;\n          url = body.external_urls?.spotify;\n          tracks = await this.#getFullItems(body);\n          break;\n        }\n        case \"playlist\": {\n          const { body } = await api.getPlaylist(id);\n          name = body.name;\n          thumbnail = body.images?.[0]?.url;\n          url = body.external_urls?.spotify;\n          tracks = (await this.#getFullItems(body)).map(i => i.track);\n          break;\n        }\n        case \"artist\": {\n          const { body } = await api.getArtist(id);\n          name = body.name;\n          thumbnail = body.images?.[0]?.url;\n          url = body.external_urls?.spotify;\n          tracks = (await api.getArtistTopTracks(id, this.topTracksCountry)).body.tracks;\n          break;\n        }\n      }\n    } catch (e: any) {\n      throw apiError(e);\n    }\n    return {\n      type: parsedUrl.type,\n      name,\n      thumbnail,\n      url,\n      tracks: tracks.filter(t => t?.type === \"track\"),\n    };\n  }\n\n  #getFullItems(data: SpotifyApi.SingleAlbumResponse): Promise<SpotifyApi.TrackObjectSimplified[]>;\n  #getFullItems(data: SpotifyApi.SinglePlaylistResponse): Promise<SpotifyApi.PlaylistTrackObject[]>;\n  async #getFullItems(data: SpotifyApi.SingleAlbumResponse | SpotifyApi.SinglePlaylistResponse) {\n    const items: (SpotifyApi.TrackObjectSimplified | SpotifyApi.PlaylistTrackObject)[] = data.tracks.items;\n    const isPlaylist = data.type === \"playlist\";\n    const limit = isPlaylist ? 100 : 50;\n    const method = isPlaylist ? \"getPlaylistTracks\" : \"getAlbumTracks\";\n    while (data.tracks.next) {\n      await this.refreshToken();\n      data.tracks = (await api[method](data.id, { offset: data.tracks.offset + data.tracks.limit, limit })).body;\n      items.push(...data.tracks.items);\n    }\n    return items;\n  }\n}\n"],"mappings":"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","names":["SpotifyWebApi","SpotifyInfo","parseSpotifyUri","import_distube"]}