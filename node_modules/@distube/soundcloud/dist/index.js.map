{"version":3,"sources":["../index.ts"],"sourcesContent":["import SoundCloud from \"soundcloud.ts\";\nimport { DisTubeError, ExtractorPlugin, Playlist, Song, checkInvalidKey } from \"distube\";\nimport type { GuildMember } from \"discord.js\";\nimport type { OtherSongInfo, PlaylistInfo } from \"distube\";\nimport type { SoundcloudPlaylistV2, SoundcloudTrackV2 } from \"soundcloud.ts\";\nconst SC = new SoundCloud();\n\ntype Falsy = undefined | null | false | 0 | \"\";\nconst isTruthy = <T>(x: T | Falsy): x is T => Boolean(x);\nexport enum SearchType {\n  Track = \"track\",\n  Playlist = \"playlist\",\n}\n\nexport interface SoundCloudPluginOptions {\n  clientId?: string;\n  oauthToken?: string;\n}\n\nexport class SoundCloudPlugin extends ExtractorPlugin {\n  #sc: SoundCloud;\n  constructor(options: SoundCloudPluginOptions = {}) {\n    super();\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new DisTubeError(\"INVALID_TYPE\", [\"object\", \"undefined\"], options, \"SoundCloudPluginOptions\");\n    }\n    checkInvalidKey(options, [\"clientId\", \"oauthToken\"], \"SoundCloudPluginOptions\");\n    if (options.clientId && typeof options.clientId !== \"string\") {\n      throw new DisTubeError(\"INVALID_TYPE\", \"string\", options.clientId, \"clientId\");\n    }\n    if (options.oauthToken && typeof options.oauthToken !== \"string\") {\n      throw new DisTubeError(\"INVALID_TYPE\", \"string\", options.oauthToken, \"oauthToken\");\n    }\n    this.#sc = new SoundCloud(options?.clientId, options?.oauthToken);\n  }\n  static search(query: string, type?: SearchType.Track, limit?: number): Promise<Song<undefined>[]>;\n  static search(query: string, type: SearchType.Playlist, limit?: number): Promise<Playlist<undefined>[]>;\n  static search(query: string, type?: SearchType, limit?: number): Promise<Song<undefined>[] | Playlist<undefined>[]>;\n  static async search(query: string, type: SearchType = SearchType.Track, limit = 10) {\n    if (typeof query !== \"string\") {\n      throw new DisTubeError(\"INVALID_TYPE\", \"string\", query, \"query\");\n    }\n    if (!Object.values(SearchType).includes(type)) {\n      throw new DisTubeError(\"INVALID_TYPE\", Object.values(SearchType), type, \"type\");\n    }\n    if (typeof limit !== \"number\" || limit < 1 || !Number.isInteger(limit)) {\n      throw new DisTubeError(\"INVALID_TYPE\", \"natural number\", limit, \"limit\");\n    }\n\n    switch (type) {\n      case SearchType.Track: {\n        const data = await SC.tracks.searchV2({ q: query, limit });\n        if (!data?.collection?.length) {\n          throw new DisTubeError(\"SOUNDCLOUD_PLUGIN_NO_RESULT\", `Cannot find any \"${query}\" ${type} on SoundCloud!`);\n        }\n        return data.collection.map(t => new Song(new SoundCloudTrack(t)));\n      }\n      case SearchType.Playlist: {\n        const data = await SC.playlists.searchV2({ q: query, limit });\n        const playlists = data.collection;\n        return (\n          await Promise.all(playlists.map(async p => new Playlist(new SoundCloudPlaylist(await SC.playlists.fetch(p)))))\n        ).filter(isTruthy);\n      }\n      default:\n        throw new DisTubeError(\"SOUNDCLOUD_PLUGIN_UNSUPPORTED_TYPE\", `${type} search is not supported!`);\n    }\n  }\n\n  search(query: string, type?: SearchType.Track, limit?: number): Promise<Song<undefined>[]>;\n  search(query: string, type: SearchType.Playlist, limit?: number): Promise<Playlist<undefined>[]>;\n  search(query: string, type?: SearchType, limit?: number): Promise<Song<undefined>[] | Playlist<undefined>[]>;\n  search(query: string, type: SearchType = SearchType.Track, limit = 10) {\n    return SoundCloudPlugin.search(query, type, limit);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  override async validate(url: string) {\n    return /^https?:\\/\\/(?:(?:www|m)\\.)?soundcloud\\.com\\/(.*)$/.test(url);\n  }\n\n  async resolve(url: string, options: { member?: GuildMember; metadata?: any }) {\n    const opt = { ...options, source: \"soundcloud\" };\n    url = url.replace(/:\\/\\/(m|www)\\./g, \"://\");\n    const data = await this.#sc.resolve.getV2(url, true).catch(() => undefined);\n    if (!data || ![\"track\", \"playlist\"].includes(data.kind)) {\n      throw new DisTubeError(\"SOUNDCLOUD_PLUGIN_NOT_SUPPORTED\", \"Only public links are supported.\");\n    }\n\n    return data.kind === \"playlist\"\n      ? new Playlist(new SoundCloudPlaylist(await this.#sc.playlists.fetch(data)), opt)\n      : new Song(new SoundCloudTrack(data), opt);\n  }\n\n  override async getRelatedSongs(url: string | number) {\n    const related = await this.#sc.tracks.relatedV2(url, 10);\n    return related.filter(t => t.title).map(t => new Song(new SoundCloudTrack(t)));\n  }\n\n  override async getStreamURL(url: string) {\n    const stream = await this.#sc.util.streamLink(url);\n    if (!stream) {\n      throw new DisTubeError(\n        \"SOUNDCLOUD_PLUGIN_RATE_LIMITED\",\n        \"Reached SoundCloud rate limits\\nSee more: https://developers.soundcloud.com/docs/api/rate-limits#play-requests\",\n      );\n    }\n    return stream;\n  }\n}\n\nclass SoundCloudTrack implements OtherSongInfo {\n  src: \"soundcloud\";\n  id: string;\n  name: string;\n  url: string;\n  thumbnail: string;\n  duration: number;\n  views: number;\n  reposts: number;\n  uploader: string;\n  uploader_url: string;\n  constructor(info: SoundcloudTrackV2) {\n    this.src = \"soundcloud\";\n    this.id = info.id.toString();\n    this.name = info.title;\n    this.url = info.permalink_url;\n    this.thumbnail = info.artwork_url;\n    this.duration = info.duration / 1000;\n    this.views = info.playback_count;\n    this.reposts = info.reposts_count;\n    this.uploader = info.user?.username;\n    this.uploader_url = info.user?.permalink_url;\n  }\n}\n\nclass SoundCloudPlaylist implements PlaylistInfo {\n  source: \"soundcloud\";\n  songs: Song[];\n  id: number;\n  name: string;\n  url: string;\n  thumbnail?: string;\n  constructor(info: SoundcloudPlaylistV2) {\n    this.source = \"soundcloud\";\n    this.id = info.id;\n    this.name = info.title;\n    this.url = info.permalink_url;\n    this.thumbnail = info.artwork_url ?? undefined;\n    if (!info.tracks?.length) throw new DisTubeError(\"SOUNDCLOUD_PLUGIN_EMPTY_PLAYLIST\", \"Playlist is empty.\");\n    this.songs = info.tracks.map(s => new Song(new SoundCloudTrack(s)));\n  }\n}\n\nexport default SoundCloudPlugin;\n"],"mappings":"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","names":["SoundCloud","SearchType"]}